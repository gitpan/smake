.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH SMAKE 1 "EN" "4/May/97" "Ralf S. Engelschall"
.IX Title "SMAKE 1"
.UC
.IX Name "SMake - Makefile generator"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
SMake \- Makefile generator
.SH "VERSION"
.IX Header "VERSION"
1.2b1 (04-05-1997)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\fBsmake\fR
[\fB\-I\fR \fIdirectory\fR|\fIpathlist\fR]
[\fB\-o\fR \fIoutputfile\fR]
[\fB\-x\fR]
[\fB\-V\fR]
[\fB\-h\fR]
\fIsmakefile\fR
.PP
\fBsmkmf\fR
[\fB\-I\fR \fIdirectory\fR|\fIpathlist\fR]
[\fB\-a\fR]
[\fB\-q\fR]
[\fB\-V\fR]
[\fB\-h\fR]
[\fIdirectory\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\fBSMake\fR is a powerful mechanism to generate standard \fIMakefile\fRs out of
skeleton \fIMakefile\fRs which only provide the essential parts.  The missing
stuff gets automatically filled in by shared include files. A great scheme to
create a huge Makefile hierarchy and to keep it consistent for the time of
development.  The trick is that it merges the skeleton (\fISMakefile\fR) and the
templates (Include files) in a priority-driven way, i.e. defines and targets
can be overwritten. The idea is taken from X Consortiums \fBImake\fR, but the
goal here is not inherited system independence for the Makefiles, the goal is
consistency and power without the need of manually maintaining a Makefile
hierarchy consisting of plain Makefiles. 
.PP
Notice that \fBSMake\fR is a Makefile \fIgenerator\fR, not an \fIevaluator\fR like
\fImake\fR, i.e. it generates standard Makefiles at development which are later
evaluated by the standard \fImake\fR tool under compile-time. This is an
important fact, because the drawback of most enhanced Make derivates (like GNU
Make, BSD Make, etc.) is that one needs them under compile-time, i.e.  the
user has to install it on his system first. There is no such need when using
\fBSMake\fR because the result of every \fBSMake\fR run is a standard \fIMakefile\fR
which usually can be interpreted by any \fImake\fR. This does not mean you cannot
use features of your enhanced Make, it does only mean that \fBSMake\fR features
are expanded to standard \fImake\fR features.
.PP
SMake provides you with the following features:
.Ip "\fBInclude directive to integrate external files\fR" 4
.IX Item "\fBInclude directive to integrate external files\fR"
You can use include statements like the one found in \s-1BSD\s0 \fImake\fR\|(1) to tell
\fBSMake\fR to integrate an external file at that position.   Say you have an
external file \fIsmk.bar\fR
.Sp
.Vb 2
\&  BAR
\&  BAZ
.Ve
and a \fISMakefile\fR with the following contents:
.Sp
.Vb 3
\&  FOO
\&  .include <smk.bar>
\&  QUUX
.Ve
Then the generated \fIMakefile\fR reads:
.Sp
.Vb 4
\&  FOO
\&  BAR
\&  BAZ
\&  QUUX
.Ve
Use \f(CW.include "\fR\fIfile\fR\f(CW"\fR to ignore the current include-path and read just
from the absolute path \fIfile\fR.
.Ip "\fBOption directive to overwrite command line options\fR" 4
.IX Item "\fBOption directive to overwrite command line options\fR"
You can use the \f(CW.opt\fR directive to set any options which will overwrite the
ones given on the command line.  For example, if you run
.Sp
.Vb 1
\&  $ smake SMakefile
.Ve
per default the file \fIMakefile\fR will be generated. If you always want the
output to be written to a file named \fIMakefile.in\fR (for instance when using
the \s-1GNU\s0 autoconf package), you can add
.Sp
.Vb 1
\&  .opt -o Makefile.in
.Ve
anywhere in \fISMakefile\fR.
.Ip "\fBPriority directive to set current processing priority\fR" 4
.IX Item "\fBPriority directive to set current processing priority\fR"
Use the \f(CW.pri\fR directive to increment, decrement or absolutely set the
processing priority which controls which \fIdefine\fR and \fItarget\fR blocks are
used or removed in the output.  Enclose a block in pairs of decrement and
increment settings to let it be overwritable by higher priority ones.
.Sp
An trivial example: When you have a \fISMakefile\fR
.Sp
.Vb 12
\&  .pri -10
\&  DEFINE = VALUE1
\&  target: source1 source2
\&    command1
\&    command2
\&  .pri +10
\&  
\&  DEFINE = VALUE2
\&  target: source3
\&    command3
\&    command4
\&      :
.Ve
the generated \fIMakefile\fR would result in
.Sp
.Vb 6
\&      :
\&  DEFINE = VALUE2
\&  target: source3
\&    command3
\&    command4
\&      :
.Ve
You think this is silly? Yes, but only when used in such a simple form inside
a single file. It is \fBSMake\fR's primary feature and should be used as follows
in practice:
.Sp
Say, you have the external files \fIsmk.stddef\fR
.Sp
.Vb 10
\&  .pri -1
\&  SRCS = 
\&  HDRS = 
\&  OBJS = 
\&  MISC = 
\&  
\&  TARGET = 
\&  
\&  DISTFILES = $(SRCS) $(HDRS) $(MISC)
\&  .pri +1
.Ve
and \fIsmk.stdtarget\fR:
.Sp
.Vb 11
\&  .pri -1
\&  
\&  all: $(TARGET)
\&  
\&  clean:
\&    rm -f $(OBJS) $(TARGETS)
\&  
\&  dist:
\&    tar cvf dist.tar $(DISTFILES)
\&  
\&  .pri +1
.Ve
Now a \fISMakefile\fR like 
.Sp
.Vb 18
\&  .include <smk.stddef>
\&  
\&  SRCS = testprog.y
\&  OBJS = testprog.c
\&  TARGET = testprog
\&   
\&  .include <smk.stdtarget>
\&   
\&  testprog.c: testprog.y
\&    yacc -v testprog.y
\&   
\&  testprog: testprog.c
\&    cc -o testprog testprog.c
\&   
\&  clean:
\&    rm -f $(OBJS) $(TARGET) *.output
\&  
\&will result in the following F<Makefile>:
.Ve
.Vb 2
\&  HDRS = 
\&  MISC = 
.Ve
.Vb 19
\&  DISTFILES = $(SRCS) $(HDRS) $(MISC)
\&  
\&  SRCS = testprog.y
\&  OBJS = testprog.c
\&  TARGET = testprog
\&  
\&  all: $(TARGET)
\&  
\&  dist:
\&    tar cvf dist.tar $(DISTFILES)
\& 
\&  testprog.c: testprog.y
\&    yacc -v testprog.y
\& 
\&  testprog: testprog.c
\&    cc -o testprog testprog.c
\& 
\&  clean:
\&    rm -f $(OBJS) $(TARGET) *.output
.Ve
For more complex examples look at the files inside the distributions
\fIinclude\fR subdir.
.PP
These three directives gives you the power to create very short \fISMakefile\fRs
which will be automatically completed by \fBSMake\fR. Write complex include files
which do all needed things and overwrite any locally different things (i.e.
defines and targets) inside the \fISMakefile\fR.
.PP
The program \fBSMkMf\fR is similar to \fIxmkmf\fR and just simplifies the task of
running \fIsmake\fR with appropriate include options over all \fISMakefile\fRs in a
subtree. Here the option \fB\-I\fR is adjusted for each subtree path. Use this as
the favorite frontend on the command line.
.SH "OPTIONS"
.IX Header "OPTIONS"
.Ip "\fB\-I\fR \fIdirectory\fR|\fIpathlist\fR" 4
.IX Item "\fB\-I\fR \fIdirectory\fR|\fIpathlist\fR"
Here the argument is either a plain \fIdirectory\fR or a colon seperated
\fIpathlist\fR of directories. \fBSMake\fR looks for include files in these
directories.  The current working directory (``\f(CW.\fR'') and the parent
directory (``\f(CW..\fR'') are always part of the include-path.
.Ip "\fB\-o\fR \fIoutputfile\fR" 4
.IX Item "\fB\-o\fR \fIoutputfile\fR"
Use \fIoutputfile\fR as the filename of the generated Makefile instead of
\fIMakefile\fR.
.Ip "\fB\-a\fR" 4
.IX Item "\fB\-a\fR"
Forces \fBSMkMf\fR to operate on all \fISMakefile\fRs recursively found in the
current subtree.  [\fIsmkmf\fR only].
.Ip "\fB\-q\fR" 4
.IX Item "\fB\-q\fR"
Forces quiet mode where no processing information is displayed.  [\fIsmkmf\fR
only].
.Ip "\fB\-x\fR" 4
.IX Item "\fB\-x\fR"
Print debugging information in addition to normal processing. The debugging
information gives hints about the correct parsing of the input \fISMakefile\fR.
[\fIsmake\fR only]
.Ip "\fB\-V\fR" 4
.IX Item "\fB\-V\fR"
Display the version identification string.
.Ip "\fB\-h\fR" 4
.IX Item "\fB\-h\fR"
Display the usage summary.
.SH "AUTHOR"
.IX Header "AUTHOR"
.PP
.Vb 3
\&  Ralf S. Engelschall
\&  rse@engelschall.com
\&  www.engelschall.com
.Ve
.SH "SEEALSO"
.IX Header "SEEALSO"
\fImake\fR\|(1)

.rn }` ''
